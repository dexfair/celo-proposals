# CIP [0020]: Generic hash function support via extensible precompile

- Date: 2020-09-4
- Author: @prestwich (James Prestwich)
- Status: WIP

### Terminology

The key words "MUST", "MUST NOT", "SHOULD", and "MAY" in this document are to be interpreted as described in 
[RFC 2119](https://www.rfc-editor.org/rfc/rfc2119.html).

## Overview

As a descendant of the EVM, Celo supports only a handful of common hash 
functions. This restricts the design-space of Celo protocols, and 

## Goals

- Provide support for common cryptographic hash functions
- Expand options for on-chain verification of protocols not specifically 
designed for EVM compatibility
    - e.g. Verification of off-chain signatures using Blake2Xs, including Celo's 
    own epoch commitments within a smart contract.
    - e.g. Verification of remote Proof of Work from a wide variety of chains
- Provide a clear route for acceptance and adoption of additional hash functions

## Proposed Solution

Introduce a new precompiled contract at address [TBD] that provides access to 
a set of pre-determined hash functions. The input to this pre-compile consists 
of a one-byte selector, a function-specific parameter block, and the preimage. 
The output of this pre-compile is dependent on the selector, and may be fixed- 
or variable-length. If the selector is unknown (not on the current 
compatibility list), or the function-specific, the precompile MUST return an 
error.

### Proposing an extension

To be eligible for inclusion, a proposed hash function meet the following 
criteria:

1. There MUST be a standardized specification for the function.
1. There MUST be an existing high-quality implementation in Go.
    1. The proposer SHOULD provide an implementation of the precompile 
    extension.
1. The function MUST be pure.
    1. This is intended to disqualify `ethash` and other stateful functions.
1. The function MUST NOT be memory intensive
    1. This is intended to disqualify "memory-hard" hash functions and other 
    potential DoS vectors
    1. E.g. `scrypt`, `argon`
1. The function SHOULD NOT be a combination of other hash functions
    1. Prefer adding each component separately, and building the composition
    as a Solidity function.
    1. This is intended to disqualify common PoW-specific combinations.
    1. E.g. `sha256d`, `X11`,

Once these criteria are met the function must be proposed via a pull request. 
The pull request SHOULD include a link to an existing implementation and 
concrete use case for the new hash function. The pull request MUST be named 
according to the following template: `[CIP-0020 Extension] DigestFunctionName`.

The pull request MUST update this CIP with the following information:

1. A new row in the table below
    1. The status MUST be set to `Proposed`.
    1. The selector MUST be marked `TODO`. Selectors will be assigned by the 
    reviewer, not the proposer.
1. If any function-specific parameters are required:
    1. A link to full documentation in a new file in the `CIP-0020/` folder.
1. If the ouput is not a fixed-length digest:
    1. A link to full documentation in a new file in the `CIP-0020/` folder.


The pull request MUST NOT:

1. Modify any existing table row or text outside of the table.
1. Conflict with the selector or name of any existing function.

### Review of new hash functions

Reviewers MAY ask the proposer for additional justification or to clarify 
decisions made with respect to the input and output formats. Reviewers SHOULD 
accept any proposal that meets all criteria and contains a well-tested 
implementation.



### Supported Digest Functions

<!--
Update using https://www.tablesgenerator.com/markdown_tables
-->

| Selector | Function Name | Extended Docs | Input Format  | Output Format | Link to specification                                            | Status   |
|----------|---------------|---------------|---------------|---------------|------------------------------------------------------------------|----------|
| 0x00     | SHA3-256      | n/a           | preimage only | 32 bytes      | [Link](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf) | Proposed |
| 0x01     | SHA3-512      | n/a           | preimage only | 64 bytes      | [Link](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf) | Proposed |
| 0x02     | Keccak-512    | n/a           | preimage only | 64 bytes      | [Link](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf) | Proposed |
| 0x10     | Blake2Xs      | TODO          | TODO          | Variable      |                                                                  | Proposed |

## Alternative Solutions

I considered adding one precompile per hash function, with each function 
having its own CIP. This would use a potentially large, fragmented, portion
of the precompile address space. Subjecting a new hash function to the full CIP
review process seems unnecessary, as the use cases are clear and the risk is 
low.

## Risks

- This is a permanent departure from compatibility with the Ethereum EVM, and 
its functionality ought to be wrapped in a Celo-specific contract to prevent 
accidental use in an Ethereum-targeted contract.

- Given that this is a pure function exposed at the contract layer, it is 
unlikely to have a significant risk on the consensus or governance processes.

- Each hash function will need to be priced separately. The pricing function for
this precompile will grow in complexity over time.

- If more than 200 hash functions are merged, the selector space will become 
crowded and we will need to plan to add a second selector byte.

## Implementation

* To follow.
